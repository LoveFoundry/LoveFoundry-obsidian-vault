
#### Лента юзеров (в виде горизонтальной очереди в верху страницы)


##### Реализация (FrontEnd)

Обмен данными будет происходить через **WebSocket**
==Требуется дальнейшая разработка реализации== 


##### Реализация (BackEnd)

Оптимальный способ реализовать эту фичу в виде **очереди (деки)**,

Реализация хранения будет на redis и пушинг с помощью Lua скрипта, который должен обеспечить потокобезопасность добавления в начало и удаления из конца, так же Lua скрипты снижают сетевую задержку, потому что выполняются на самом сервере Redis

##### Тестовая реализация (BackEnd):

**Почти сделана тестовая реализация** 

https://github.com/LoveFoundry/redisQueueTest

**Ссылка на PostMan**

https://lovefoundry.postman.co/workspace/LoveFoundy-FeaturesTest~c6c06519-a0ac-4609-a524-2da74bd0ab58/folder/44166927-f2d3d5a9-8def-4852-abb9-4c045bc914f9?action=share&creator=44166927&ctx=documentationcfd 

Документация тестовой реализации: (**==пока что тестируется==** ) 

Реализован простенький REST API сервер, по файловой структуре которая примерно будет в проекте, нету сервисного слоя потому что в тестовой реализации он не нужен, реализован Redis провайдер и одна ручка /addMessage 

в редис отправляется вот такой **Lua** скрипт:

    script := redis.NewScript(`  
        local k = KEYS[1] - обьявление ключа
        local payload = ARGV[1] - проброска body сообщения
        local maxlen = tonumber(ARGV[2]) - установка максимальной длины очереди           (управляется в docker compose)
        local repeatNum = tonumber(ARGV[3]) - установка динамической проброски            количество повторений сообщеия
        redis.call('LPUSH', k, payload) - пушим тело сообщения
        redis.call('LTRIM', k, 0, repeatNum - 1) - очищяем очередь чтобы она была         (максимальная длина минус 1)
        return redis.call('LLEN', k)`)  - возвращяет кол во элементов в очереди
    script.Run(ctx, provider.client, []string{provider.key}, m, provider.maxLen,      repeatNum) - запуск скрипта с проброской всех параметров

Все компоненты (сам go сервис и redis) оборачиваются в docker контейнеры, и запускаются через docker compose  
в docker compose уже прокиданы env зависимости 

`environment:`  
  `PORT: "8080"`  
  `REDIS_ADDR: "redis:6379"`  
  `QUEUE_KEY: "queue:messages"`  
  `MAXLEN: "50"`  
`ports:`  
  - `"8080:8080"`


команда для запуска:

```
docker compose up -d
```


Вопросы реализации: 

В каком сервисе разместить эту фичу
 

#### Лента юзеров (в виде горизонтальной очереди в верху страницы)


##### Реализация (FrontEnd)

Обмен данными будет происходить через **WebSocket**
==Требуется дальнейшая разработка реализации== 


##### Реализация (BackEnd)

Оптимальный способ реализовать эту фичу в виде **очереди (деки)**,

Реализация хранения будет на redis и пушинг с помощью Lua скрипта, который должен обеспечить потокобезопасность добавления в начало и удаления из конца, так же Lua скрипты снижают сетевую задержку, потому что выполняются на самом сервере Redis

##### Тестовая реализация (BackEnd):

**Почти сделана тестовая реализация** 

https://github.com/LoveFoundry/redisQueueTest

##### **Ссылка на PostMan**

https://lovefoundry.postman.co/workspace/LoveFoundy-FeaturesTest~c6c06519-a0ac-4609-a524-2da74bd0ab58/folder/44166927-f2d3d5a9-8def-4852-abb9-4c045bc914f9?action=share&creator=44166927&ctx=documentationcfd 

Документация тестовой реализации:

Реализован простенький REST API сервер, по файловой структуре которая примерно будет в проекте, нету сервисного слоя потому что в тестовой реализации он не нужен, реализован Redis провайдер и одна ручка /addMessage 

Структура запросов в тестовой реализации

**POST** http://localhost:8080/api/addMessage
body запроса:
`{`
`"id": "23", // id юзера`
`"message": "{{$randomLoremText}}", // сообщение`
`"repeat_num": 10// количество повторений сообщения`
`}`
Возвращает статус Ok

GET http://localhost:8080/api/getMessages
Возвращает
`{`
    `"messages": [`
        `{`
            `"user_id": "12",`
            `"message": "quia et maiores"`
        `},`
        `{`
            `"user_id": "12",`
            `"message": "quia et maiores"`
        `},`
        `{`
            `"user_id": "",`
            `"message": "quia et maiores"`
        `},`
        `{`
            `"user_id": "12",`
            `"message": "odio"`
        `},`
        `{`
            `"user_id": "12",`
            `"message": "odio"`
        `},`
    `]`
`}`
###### В редис отправляется вот такой **Lua** скрипт:

    script := redis.NewScript(`  
       local k = KEYS[1]
       local payload = ARGV[1]
       local maxlen = tonumber(ARGV[2])
	   local repeatNum = tonumber(ARGV[3])
	   local args = {k}
	   for i = 1, repeatNum do
	   args[#args+1] = payload - цикл с количеством итераций создания сообщений
	   end
	   redis.call('LPUSH', unpack(args))
	   redis.call('LTRIM', k, 0, maxlen - 1)
	   return redis.call('LLEN', k)`
	   ) - запуск скрипта с проброской всех параметров

Все компоненты (сам go сервис и redis) оборачиваются в docker контейнеры, и запускаются через docker compose  
в docker compose уже прокиданы env зависимости 

`environment:`  
  `PORT: "8080"`  
  `REDIS_ADDR: "redis:6379"`  
  `QUEUE_KEY: "queue:messages"`  
  `MAXLEN: "50"`  
`ports:`  
  - `"8080:8080"`


команда для запуска:

```
docker compose up -d
```


Вопросы реализации: 

В каком сервисе разместить эту фичу
 
## Для чего нужен планировщик?

*Задействование всех ресурсов*
У процессора много ядер и мы должны оптимизировано задействовать его ядра, например у процессора 4 ядра и 4 задачи и мы видим ситуацию что 2 таски раскинуты по двум ядрам и на 3 ядре одна задача выполняется а одна ожидает выполнение первой, а 4 ядро просто простаивает у нас есть ресурс которую мы не задействуем, так что мы должны понимать устройство планировщика чтобы оптимизировано его использовать

*Конкурентная работа должна быть дешевой*, мы хотим создавать много горутин и делать это дешево для ресурсов компьютера 

*Простота* 

```
// синхроннно 
runTask()

// асинхронно 
go runTask()
```


Конкурентность это больше про стиль написание кода
При конкурентом выполнении планировщик сам выбирает какие ему строчки выполнять он может выполнять целые блоки 1 задачи а потом переходить на вторую, может выполнять по строчке потом переходить на другую

Паралельность это про выполнение кода 
Код при параллельном выполнении в прямом смысле выполняет строчки функций параллельно   

Представим у нас есть ядро процессора он имеет определенный слот выполнения задачи, так же есть условная очередь, этим всем заведовать будет планировщик операционной системы 

Тред - это последовательность команд которая выполняется в рамках одной задачи, есть три состояния треда:
1. Executing - выполняются на ядре
2. Runnable - готовы выполнятся но ждут своей очереди 
3. Waiting - ждущие треды которые не готовы к выполнению, они чего ждут 

Планировщик OS в случайные моменты может менять runnable и executing местами (переключать контекст) - это называется переключением контекста (context switching) - не дешевая операция, интересный момент мы не можем предвидит и не можем на него повлиять , такое поведение называется вытесняющей многозадачностей, в Go многозадачность кооперативная 

Треды - это дорого, в отличие от горутин, чем больше тредов, тем больше переключений а переключения это дорого, например если у нас есть 2 задачи но переключение между ними будет небольшим это хорошо, а например если у нас намного больше тредов и между каждыми переключения контекста, то это уже другая ситуация особенно если задачи могут быть небольшими то переключение может занять больше времени чем сама полезной работы, нам нужно стараться минимизировать кол во тредов  

Планировщик Go 
У нас есть синхронный код и мы хотим сделать из него асинхронный, нам нужен планировщик Go это по факту те же треды в планировщике операционной системы, отличие в том что планировщик ОС живет в Kernel Space - треды управляются непосредственно ОС а планировщик Go в User Space - горутины  управляются Go, то есть у нас есть контроль над ними, По факту можно сказать что планировщик Go это просто оптимизация планировщика ОС  

Го рутины имееют такие же состояния что и треды 

GMP-модель - 